/**
 * Integration tests for HTML generation.
 *
 * Tests for generating HTML from an AST after expanding components and slots.
 */

import generateCode from 'pug-code-gen'
import { describe, expect, test } from 'vitest'
import { ASTTransformer } from '../../src/core/astTransformer.js'
import { ComponentRegistry } from '../../src/core/componentRegistry.js'
import { SlotResolver } from '../../src/core/slotResolver.js'
import type { Block } from '../../src/types/pug.js'
import { parsePug } from '../helpers/parsePug.js'

/**
 * A simple implementation of the Pug runtime.
 *
 * Required to execute the code generated by pug-code-gen.
 */
function createPugRuntime() {
  return {
    attr: (key: string, val: unknown, escaped: boolean) => {
      if (val === true) return ` ${key}`
      if (val === false || val == null) return ''
      return escaped
        ? ` ${key}="${String(val).replace(/"/g, '&quot;')}"`
        : ` ${key}="${val}"`
    },
    attrs: (attrs: Record<string, unknown>) => {
      const result: string[] = []
      for (const [key, val] of Object.entries(attrs)) {
        if (val === true) result.push(` ${key}`)
        else if (val !== false && val != null)
          result.push(` ${key}="${String(val).replace(/"/g, '&quot;')}"`)
      }
      return result.join('')
    },
    escape: (str: string) =>
      String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;'),
    rethrow: (err: Error) => {
      throw err
    },
    // Merge function used by &attributes
    merge: (...args: unknown[]) => {
      // If the first argument is an array, expand it
      const sources: Record<string, unknown>[] =
        args.length === 1 && Array.isArray(args[0])
          ? args[0]
          : (args as Record<string, unknown>[])

      const base: Record<string, unknown> = {}

      for (const source of sources) {
        if (!source || typeof source !== 'object') continue

        for (const [key, val] of Object.entries(
          source as Record<string, unknown>,
        )) {
          if (key === 'class') {
            // Special handling for class attribute: concatenate arrays or space-separated strings
            const baseClass = base.class
            const sourceClass = val

            if (baseClass && sourceClass) {
              const baseClasses = Array.isArray(baseClass)
                ? baseClass
                : String(baseClass).split(' ')
              const sourceClasses = Array.isArray(sourceClass)
                ? sourceClass
                : String(sourceClass).split(' ')

              base.class = [...baseClasses, ...sourceClasses]
                .filter(Boolean)
                .join(' ')
            } else {
              base.class = sourceClass || baseClass
            }
          } else {
            // Other attributes are overwritten
            base[key] = val
          }
        }
      }
      return base
    },
  }
}

/**
 * Generates HTML from an AST.
 *
 * @param ast - The transformed AST.
 * @returns The generated HTML.
 */
function generateHTML(ast: Block): string {
  try {
    const generatedCode = generateCode(ast, {
      compileDebug: false,
      pretty: true,
    })

    const pugRuntime = createPugRuntime()

    // The code generated by pug-code-gen is in the format: function template(locals).
    // Make the pug object available within the scope.
    // eslint-disable-next-line no-new-func
    const templateFn = new Function(
      'pug',
      `
      ${generatedCode}
      return template;
      `,
    )

    // Get the template function.
    const template = templateFn(pugRuntime)

    if (typeof template !== 'function') {
      throw new Error('Template function was not returned from generated code')
    }

    // Pass an empty object as locals.
    const html = template({})

    // If html is undefined or null, return an empty string.
    if (html == null) {
      return ''
    }

    return String(html)
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`HTML generation failed: ${error.message}`)
    }
    throw error
  }
}

describe('HTML Generation Integration', () => {
  test('should expand a simple component and generate HTML', () => {
    const source = `
component Card()
  .card
    slot(header)
      p Default Header
    slot(body)
      p Default Body

Card()
  slot(header)
    h1 Title
  slot(body)
    p Content
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      expect(html).toBeDefined()
      expect(typeof html).toBe('string')

      // Verify that the component has been expanded.
      expect(html).toContain('<div class="card">')
      expect(html).toContain('<h1>Title</h1>')
      expect(html).toContain('<p>Content</p>')

      // Verify that the component definition has been removed.
      expect(html).not.toContain('component')
    }
  })

  test('should confirm that default slot content is used', () => {
    const source = `
component Card()
  .card
    slot(header)
      p Default Header
    slot(body)
      p Default Body

Card()
  slot(header)
    h1 Title
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      // The provided header slot should be used.
      expect(html).toContain('<h1>Title</h1>')

      // The body slot is not provided, so the default content should be used.
      expect(html).toContain('<p>Default Body</p>')
    }
  })

  test('should expand a component with multiple slots', () => {
    const source = `
component Card()
  .card
    .card-header
      slot(header)
        p default header
    .card-body
      slot(body)
        p default body
    .card-footer
      slot(footer)
        p default footer

Card()
  slot(header)
    h1 Title
  slot(body)
    p Content
  slot(footer)
    button OK
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      // Verify that all slots have been correctly replaced.
      expect(html).toContain('<div class="card-header">')
      expect(html).toContain('<h1>Title</h1>')
      expect(html).toContain('<div class="card-body">')
      expect(html).toContain('<p>Content</p>')
      expect(html).toContain('<div class="card-footer">')
      expect(html).toContain('<button>OK</button>')

      // Verify that default content is not used.
      expect(html).not.toContain('default header')
      expect(html).not.toContain('default body')
      expect(html).not.toContain('default footer')
    }
  })

  test('should expand multiple component calls', () => {
    const source = `
component Card()
  .card
    slot(body)
      p Default

component Button()
  button
    slot(label)
      span Click

Card()
  slot(body)
    p Card Content

Button()
  slot(label)
    span Button Label
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      // Verify that both components have been expanded.
      expect(html).toContain('<div class="card">')
      expect(html).toContain('<p>Card Content</p>')
      expect(html).toContain('<button>')
      expect(html).toContain('<span>Button Label</span>')
    }
  })

  test('should use default content if a slot is not provided', () => {
    const source = `
component Card()
  .card
    slot(header)
      p Default Header
    slot(body)
      p Default Body

Card()
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      // Verify that default content is used.
      expect(html).toContain('<p>Default Header</p>')
      expect(html).toContain('<p>Default Body</p>')
    }
  })

  test('should expand nested components', () => {
    const source = `
component Container()
  .container
    slot(content)
      p Default content

component Card()
  .card
    slot(body)
      p Default body

Container()
  slot(content)
    Card()
      slot(body)
        p Nested content
`

    const ast = parsePug(source)

    const registry = new ComponentRegistry()
    const resolver = new SlotResolver()
    const transformer = new ASTTransformer(registry, resolver)

    const transformed = transformer.transform(ast)

    expect(transformed.type).toBe('Block')

    if (transformed.type === 'Block') {
      const html = generateHTML(transformed)

      // Verify that the nested component has been expanded.
      expect(html).toContain('<div class="container">')
      expect(html).toContain('<div class="card">')
      expect(html).toContain('<p>Nested content</p>')
    }
  })
})
